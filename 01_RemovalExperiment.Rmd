---
title: "01_RemovalExperiment"
author: "Georg V. Flückiger"
date: "2025-05-04"
output: html_document
---

############################################################

# Purpose
Analyze species-specific recovery and community-level responses to an invasive plant management experiment along an elevation gradient in the Swiss Alps.

# Description
This R Markdown document contains the full data processing and statistical analyses for the removal experiment of three nonnative plant species (Erigeron annuus, Solidago canadensis, Lupinus polyphyllus) conducted in 2021 and 2022 across an elevation gradient in the Swiss Alps. The script includes data import, cleaning, transformation of cover scores, and preparation of species-specific datasets for modeling. Subsequent steps involve fitting generalized linear mixed models (GLMMs) using beta-distributed response variables to evaluate the effects of several predictors on the recovery of the focal species as well as of other cover groups recorded in the field.

# Key steps
- Import and clean raw cover data  
- Transform cover scores to numeric proportions  
- Generate rescaled variables for modeling  
- Subset datasets by focal species  
- Fit and compare linear and polynomial GLMMs  
- Perform model diagnostics and interpret outputs  
- Visualize final results, including scatterplots with predicted lines (Fig. 3)

# Required R packages
- tidyverse: data wrangling and visualization  
- glmmTMB: beta regression mixed-effects models  
- DHARMa: residual diagnostics  
- car: Type II ANOVA and model summaries  
- ggpubr, ggsci: publication-quality visualizations

Author: Georg V. Flückiger  
Last updated: 2025-08-10

############################################################

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Main directory
main_dir <- "D:/Programming/RemovalCH_Manuscript/RemovalCH_Analyses/Data/"

# Load packages
library(tidyverse)
library(viridis)
library(glmmTMB)
library(ggpubr)
library(ggsci)
library(DHARMa)
library(MASS)
library(minqa) 
library(dplyr)
library(tidyr)
library(forcats)

# Settings
Sys.setenv(LANG = "en")

# Set ggplot theme
my_theme <- theme(panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  panel.background = element_rect(fill = "white", color = "black"),
                  plot.title = element_text(face = "bold", hjust = 0.5),
                  legend.key=element_blank())
```

# Import & clean the data

```{r}
# Load RAW removal data
removal_data <- read.csv(paste0(main_dir, "/RemovalData_RAW.csv"), 
                         header = TRUE, sep = ";", stringsAsFactors = T)

# Add rescaled elevation as variable
removal_data$elevation_rescaled <- scales::rescale(removal_data$elevation, to = c(0.001, 0.999))

# Transform cover scores to percentages, proportions and rescale
removal_sub <- removal_data[, c(3:4, 6:12)]
mapping <- list("1" = 0.05, "2" = 0.55, "3" = 3, "4" = 7.5, "5" = 17.5, "6" = 37.5, "7" = 62.5, "8" = 87.5)
removal_sub <- as.data.frame(apply(removal_sub, c(1,2), function(x) ifelse(x == 0, 0, mapping[x][[1]])))
removal_sub_prop <- removal_sub / 100
removal_sub_prop_rescaled <- removal_sub_prop
removal_sub_prop_rescaled <- as.data.frame(apply(removal_sub_prop_rescaled, 2, function(x) {
  scales::rescale(x, to = c(0.001, 0.999))}))

# Adjust names
names(removal_sub) <- paste(names(removal_sub), "percentage", sep = "_")
names(removal_sub_prop) <- paste(names(removal_sub_prop), "prop", sep = "_")
names(removal_sub_prop_rescaled) <- paste(names(removal_sub_prop), "rescaled", sep = "_")
removal_data <- cbind(removal_data, removal_sub, removal_sub_prop, removal_sub_prop_rescaled)

# Create subset of the data by species
eri_removal <- removal_data[removal_data$species == "erigeron", ]
sol_removal <- removal_data[removal_data$species == "solidago", ]
lup_removal <- removal_data[removal_data$species == "lupinus", ]

# Export important files into new directory
file_name <- "Data/RemovalData_processed_full.csv"
write.csv(removal_data, file_name)

# Set reference categories
removal_data$treatment <- relevel(removal_data$treatment, ref = "control")
removal_data$year <- factor(removal_data$year)
removal_data$year <- relevel(removal_data$year, ref = "2021")

# Create subset of the data by species
eri_removal <- removal_data[removal_data$species == "erigeron", ]
sol_removal <- removal_data[removal_data$species == "solidago", ]
lup_removal <- removal_data[removal_data$species == "lupinus", ]

# All_species list
all_species <- list(erigeron = eri_removal, 
                    solidago = sol_removal, 
                     lupinus = lup_removal)
```

################ DATA ANALYSIS #################
# Mixed Effects Models to study changes in cover of focal species

```{r}
# Formula to test model assumptions based on DHARMa package
test_mod_assumptions <- function(model){
  
  # Simulate residuals & visualize
  print(testDispersion(model))
  hist(resid(model))
  res  <-  DHARMa::simulateResiduals(model)
  plot(res, rank = T)
  
}

#### Mixed Effects Models to analyze in cover of focal species ####
# Define Model formulas
glmmTMB_formula <- as.formula(cover_focal_sp_prop_rescaled ~ year * treatment * elevation_rescaled + 
                                background_management + (1 | plotID) + (1 | site_name))
glmmTMB_formula_poly <- as.formula(cover_focal_sp_prop_rescaled ~ year * treatment * poly(elevation_rescaled,2) + 
                                     background_management + (1 | plotID) + (1 | site_name))

# Fit beta regression models for all species
eri_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula, data = eri_removal, family = beta_family())
eri_glmmTMB_poly <- glmmTMB::glmmTMB(glmmTMB_formula_poly, data = eri_removal, family = beta_family())
sol_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula, data = sol_removal, family = beta_family()) 
sol_glmmTMB_poly <- glmmTMB::glmmTMB(glmmTMB_formula_poly, data = sol_removal, family = beta_family()) 
lup_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula, data = lup_removal, family = beta_family())
lup_glmmTMB_poly <- glmmTMB::glmmTMB(glmmTMB_formula_poly, data = lup_removal, family = beta_family())

# Likelihood Ratio Test (LRT) to check which model fits better
anova(eri_glmmTMB, eri_glmmTMB_poly) # Linear is better (p > 0.05)
anova(sol_glmmTMB, sol_glmmTMB_poly) # Linear is better (p > 0.05)
anova(lup_glmmTMB, lup_glmmTMB_poly) # Polynomial is better (p < 0.05)

# Test model assumptions
test_mod_assumptions(eri_glmmTMB) 
test_mod_assumptions(sol_glmmTMB) 
test_mod_assumptions(lup_glmmTMB_poly) 

# Check Model Summaries and Anova tables
all_mods <- list(erigeron = eri_glmmTMB, solidago = sol_glmmTMB, lupinus = lup_glmmTMB_poly)
lapply(all_mods, summary)
lapply(all_mods, car::Anova)
```

Examine simpler models (dropping n.s. terms)

```{r}
# Check significance of terms in full models
cat("\n--- Full Model ANOVAs ---\n")
full_anovas <- list(
  erigeron = car::Anova(eri_glmmTMB),
  solidago = car::Anova(sol_glmmTMB),
  lupinus  = car::Anova(lup_glmmTMB_poly)
)
print(full_anovas)

# Create simplified formulas by dropping non-significant interactions
# Adjust terms based on above ANOVA results
eri_glmmTMB_simple <- update(eri_glmmTMB,
  . ~ year + elevation_rescaled + year:treatment + year:elevation_rescaled)

sol_glmmTMB_simple <- update(sol_glmmTMB,
  . ~ year + treatment + year:treatment)

lup_glmmTMB_poly_simple <- update(lup_glmmTMB_poly,
  . ~ year + treatment + background_management + year:treatment + year:poly(elevation_rescaled, 2))

# Compare full vs simplified models (Likelihood Ratio Tests)
cat("\n--- Full vs Simplified Model LRTs ---\n")
print(anova(eri_glmmTMB, eri_glmmTMB_simple))
print(anova(sol_glmmTMB, sol_glmmTMB_simple))
print(anova(lup_glmmTMB_poly, lup_glmmTMB_poly_simple))

# ANOVA tables for simplified models (to paste into response letter)
cat("\n--- Simplified Model ANOVAs ---\n")
simpl_anovas <- list(
  erigeron = car::Anova(eri_glmmTMB_simple),
  solidago = car::Anova(sol_glmmTMB_simple),
  lupinus  = car::Anova(lup_glmmTMB_poly_simple)
)
print(simpl_anovas)

# Model diagnostics for simplified models
cat("\n--- Simplified Model Diagnostics ---\n")
test_mod_assumptions(eri_glmmTMB_simple)
test_mod_assumptions(sol_glmmTMB_simple)
test_mod_assumptions(lup_glmmTMB_poly_simple)
```

Test wether there are baseline differences among plots before applying removal treatment

```{r}
# Erigeron annuus
glmm_eri <- glmmTMB(cover_focal_sp_prop_rescaled ~ treatment + (1 | site_name),  
  data = dplyr::filter(eri_removal, year == 2021),
  family = beta_family(link = "logit"))
summary(glmm_eri)

# Solidago canadensis
glmm_sol <- glmmTMB(cover_focal_sp_prop_rescaled ~ treatment + (1 | site_name),  
  data = dplyr::filter(sol_removal, year == 2021),
  family = beta_family(link = "logit"))
summary(glmm_sol)

# Lupinus polyphyllus
glmm_lup <- glmmTMB(cover_focal_sp_prop_rescaled ~ treatment + (1 | site_name),  
  data = dplyr::filter(lup_removal, year == 2021),
  family = beta_family(link = "logit"))
summary(glmm_lup)
```

# Analyses of changes in other cover groups recorded (forbs, graminoids, legumes, bare ground)

```{r}
# Define simple model formulas
forbs_formula <- as.formula(forbs_prop_rescaled ~ year * treatment * elevation_rescaled + 
                              (1 | plotID) + (1 | site_name))
graminoids_formula <- as.formula(graminoids_prop_rescaled ~ year * treatment * elevation_rescaled + 
                                   (1 | plotID) + (1 | site_name))
legumes_formula <- as.formula(legumes_prop_rescaled ~ year * treatment * elevation_rescaled + 
                                (1 | plotID) + (1 | site_name))
bare_ground_formula <- as.formula(bare_ground_prop_rescaled ~ year * treatment * elevation_rescaled + 
                                    (1 | plotID) + (1 | site_name))

# Polynomial models
forbs_formula_poly <- as.formula(forbs_prop_rescaled ~ year * treatment * poly(elevation_rescaled,2) + 
                                   (1 | plotID) + (1 | site_name))
graminoids_formula_poly <- as.formula(graminoids_prop_rescaled ~ year * treatment * poly(elevation_rescaled,2) + 
                                        (1 | plotID) + (1 | site_name))
legumes_formula_poly <- as.formula(legumes_prop_rescaled ~ year * treatment * poly(elevation_rescaled,2) + 
                                     (1 | plotID) + (1 | site_name))
bare_ground_formula_poly <- as.formula(bare_ground_prop_rescaled ~ year * treatment * poly(elevation_rescaled,2) + 
                                         (1 | plotID) + (1 | site_name))

#### ERIGERON ####
# Simple models
eri_forbs_fit <- glmmTMB::glmmTMB(forbs_formula, data = eri_removal, family = beta_family())
eri_graminoids_fit <- glmmTMB::glmmTMB(graminoids_formula, data = eri_removal, family = beta_family())
eri_legumes_fit <- glmmTMB::glmmTMB(legumes_formula, data = eri_removal, family = beta_family())
eri_bare_ground_fit <- glmmTMB::glmmTMB(bare_ground_formula, data = eri_removal, family = beta_family())

# Polynomial models
eri_forbs_fit_poly <- glmmTMB::glmmTMB(forbs_formula_poly, data = eri_removal, family = beta_family())
eri_graminoids_fit_poly <- glmmTMB::glmmTMB(graminoids_formula_poly, data = eri_removal, family = beta_family())
eri_legumes_fit_poly <- glmmTMB::glmmTMB(legumes_formula_poly, data = eri_removal, family = beta_family())
eri_bare_ground_fit_poly <- glmmTMB::glmmTMB(bare_ground_formula_poly, data = eri_removal, family = beta_family())

# Likelihood ratio Tests
anova(eri_forbs_fit, eri_forbs_fit_poly) # Linear is better (p > 0.05)
anova(eri_graminoids_fit, eri_graminoids_fit_poly) # Linear is better (p > 0.05)
anova(eri_legumes_fit, eri_legumes_fit_poly) # Linear is better (p > 0.05)
anova(eri_bare_ground_fit, eri_bare_ground_fit_poly) # Linear is better (p > 0.05)

# Test assumptions, check summary & anova tables of best models
eri_cover_group_mods <- list(eri_forbs_fit, eri_graminoids_fit, eri_legumes_fit, eri_bare_ground_fit)
lapply(eri_cover_group_mods, test_mod_assumptions)
lapply(eri_cover_group_mods, summary)
lapply(eri_cover_group_mods, car::Anova)

#### SOLIDAGO ####
# Simple models
sol_forbs_fit <- glmmTMB::glmmTMB(forbs_formula, data = sol_removal, family = beta_family())
sol_graminoids_fit <- glmmTMB::glmmTMB(graminoids_formula, data = sol_removal, family = beta_family())
sol_legumes_fit <- glmmTMB::glmmTMB(legumes_formula, data = sol_removal, family = beta_family())
sol_bare_ground_fit <- glmmTMB::glmmTMB(bare_ground_formula, data = sol_removal, family = beta_family())

# Polynomial models
sol_forbs_fit_poly <- glmmTMB::glmmTMB(forbs_formula_poly, data = sol_removal, family = beta_family())
sol_graminoids_fit_poly <- glmmTMB::glmmTMB(graminoids_formula_poly, data = sol_removal, family = beta_family())
sol_legumes_fit_poly <- glmmTMB::glmmTMB(legumes_formula_poly, data = sol_removal, family = beta_family())
sol_bare_ground_fit_poly <- glmmTMB::glmmTMB(bare_ground_formula_poly, data = sol_removal, family = beta_family())

# Likelihood ratio Tests
anova(sol_forbs_fit, sol_forbs_fit_poly) # Polynomial is better (p < 0.05)
anova(sol_graminoids_fit, sol_graminoids_fit_poly) # Polynomial is better (p < 0.05)
anova(sol_legumes_fit, sol_legumes_fit_poly) # Linear is better (p > 0.05)
anova(sol_bare_ground_fit, sol_bare_ground_fit_poly) # Linear is better (p > 0.05)

# Test assumptions, check summary & anova tables of best models
sol_cover_group_mods <- list(sol_forbs_fit_poly, sol_graminoids_fit_poly, sol_legumes_fit, sol_bare_ground_fit) 
lapply(sol_cover_group_mods, test_mod_assumptions)
lapply(sol_cover_group_mods, summary)
lapply(sol_cover_group_mods, car::Anova)

#### LUPINUS ####
# Fit models
lup_forbs_fit <- glmmTMB::glmmTMB(forbs_formula, data = lup_removal, family = beta_family())
lup_graminoids_fit <- glmmTMB::glmmTMB(graminoids_formula, data = lup_removal, family = beta_family())
lup_legumes_fit <- glmmTMB::glmmTMB(legumes_formula, data = lup_removal, family = beta_family())
lup_bare_ground_fit <- glmmTMB::glmmTMB(bare_ground_formula, data = lup_removal, family = beta_family())

# Polynomial models
lup_forbs_fit_poly <- glmmTMB::glmmTMB(forbs_formula_poly, data = lup_removal, family = beta_family())
lup_graminoids_fit_poly <- glmmTMB::glmmTMB(graminoids_formula_poly, data = lup_removal, family = beta_family())
lup_legumes_fit_poly <- glmmTMB::glmmTMB(legumes_formula_poly, data = lup_removal, family = beta_family())
lup_bare_ground_fit_poly <- glmmTMB::glmmTMB(bare_ground_formula_poly, data = lup_removal, family = beta_family())

# Likelihood ratio Tests
anova(lup_forbs_fit, lup_forbs_fit_poly) # Polynomial is better (p < 0.05)
anova(lup_graminoids_fit, lup_graminoids_fit_poly) # Linear is better (p > 0.05)
anova(lup_legumes_fit, lup_legumes_fit_poly) # Linear is better (p > 0.05)
anova(lup_bare_ground_fit, lup_bare_ground_fit_poly) # Linear is better (p > 0.05)

# Test assumptions, check summary & anova tables of best models
lup_cover_group_mods <- list(lup_forbs_fit_poly, lup_graminoids_fit, lup_legumes_fit, lup_bare_ground_fit)
lapply(lup_cover_group_mods, test_mod_assumptions)
lapply(lup_cover_group_mods, summary)
lapply(lup_cover_group_mods, car::Anova)
```

################ VISUALIZATIONS #################
# Fig. 3: Scatterplot with predicted curves (with final models)

```{r}
# Create datasets
eri_df <- data.frame(
  elevation = rep(seq(min(eri_removal$elevation), max(eri_removal$elevation), length.out = 100), 2),
  year = rep(c("2021", "2022"), each = 100),
  treatment = rep(c("control", "removal"), each = 1, times = 100))
sol_df <- data.frame(
  elevation = rep(seq(min(sol_removal$elevation), max(sol_removal$elevation), length.out = 100), 2),
  year = rep(c("2021", "2022"), each = 100),
  treatment = rep(c("control", "removal"), each = 1, times = 100))
lup_df <- data.frame(
  elevation = rep(seq(min(lup_removal$elevation), max(lup_removal$elevation), length.out = 100), 2),
  year = rep(c("2021", "2022"), each = 100),
  treatment = rep(c("control", "removal"), each = 1, times = 100))

# Define simple model formula and fit models
glmmTMB_formula <- as.formula(cover_focal_sp_prop_rescaled ~ year * treatment * elevation)
glmmTMB_formula_poly <- as.formula(cover_focal_sp_prop_rescaled ~ year * treatment * poly(elevation, 2))
eri_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula, data = eri_removal, family = beta_family())
sol_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula, data = sol_removal, family = beta_family())
lup_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula_poly, data = lup_removal, family = beta_family())

# Generate predictions and combine datasets
eri_pred_df <- eri_df %>% mutate(predicted = predict(eri_glmmTMB, newdata = ., type = "response"))
sol_pred_df <- sol_df %>% mutate(predicted = predict(sol_glmmTMB, newdata = ., type = "response"))
lup_pred_df <- lup_df %>% mutate(predicted = predict(lup_glmmTMB, newdata = ., type = "response"))
# Unscaling function: reverse scales::rescale(to = c(0.001, 0.999))
rescale_back <- function(scaled_vals, orig_min, orig_max, to = c(0.001, 0.999)) {
  (scaled_vals - to[1]) / (to[2] - to[1]) * (orig_max - orig_min) + orig_min
}

# Example: min/max per species
eri_min <- min(eri_removal$cover_focal_sp_percentage, na.rm = TRUE)
eri_max <- max(eri_removal$cover_focal_sp_percentage, na.rm = TRUE)

sol_min <- min(sol_removal$cover_focal_sp_percentage, na.rm = TRUE)
sol_max <- max(sol_removal$cover_focal_sp_percentage, na.rm = TRUE)

lup_min <- min(lup_removal$cover_focal_sp_percentage, na.rm = TRUE)
lup_max <- max(lup_removal$cover_focal_sp_percentage, na.rm = TRUE)

# Now unscale each prediction block separately
eri_pred_df$cover_focal_sp_unscaled <- rescale_back(eri_pred_df$predicted, eri_min, eri_max)
sol_pred_df$cover_focal_sp_unscaled <- rescale_back(sol_pred_df$predicted, sol_min, sol_max)
lup_pred_df$cover_focal_sp_unscaled <- rescale_back(lup_pred_df$predicted, lup_min, lup_max)

# Combine all predictions into a single dataset for plotting
all_predictions <- bind_rows(eri_pred_df %>% mutate(species = "erigeron"),
                             sol_pred_df %>% mutate(species = "solidago"),
                             lup_pred_df %>% mutate(species = "lupinus"))

# Tidy up treatment factor
all_predictions$treatment <- dplyr::recode(all_predictions$treatment,
                                           "control" = "Control",
                                           "removal" = "Removal")

# Set variables as factor
all_predictions$treatment <- factor(all_predictions$treatment)
all_predictions$year <- factor(all_predictions$year)
all_predictions$species <- factor(all_predictions$species)

# Subset predictions by species
eri_pred_df_def <- all_predictions[all_predictions$species == "erigeron", ]
sol_pred_df_def <- all_predictions[all_predictions$species == "solidago", ]
lup_pred_df_def <- all_predictions[all_predictions$species == "lupinus", ]

# Factor formatting for observed data
eri_removal$treatment <- factor(eri_removal$treatment, levels = c("control", "removal"),
                                labels = c("Control", "Removal"))
sol_removal$treatment <- factor(sol_removal$treatment, levels = c("control", "removal"),
                                labels = c("Control", "Removal"))
lup_removal$treatment <- factor(lup_removal$treatment, levels = c("control", "removal"),
                                labels = c("Control", "Removal"))

# Breaks for Erigeron based on actual cover classes, but keep min. and any values above 2.5% threshold
eri_breaks_raw <- sort(unique(eri_removal$cover_focal_sp_percentage))
eri_breaks <- c(min(eri_breaks_raw), eri_breaks_raw[eri_breaks_raw > 2.5])

# Raw Erigeron cover classes
eri_breaks_raw <- sort(unique(eri_removal$cover_focal_sp_percentage))

# Facet-aware breaks: keep min (e.g., 0) + values > 2.5%; drop "3" only in the tall (2021) panel
eri_breaks_fun <- function(lims) {
  b <- c(min(eri_breaks_raw), eri_breaks_raw[eri_breaks_raw > 2.5])
  if (max(lims) > 20) b <- b[b != 3]   # drop 3 only when the panel has a large y-range (2021)
  b[b >= lims[1] & b <= lims[2]]
}

# Create ggplots with real model predictions
(eri_plot <- ggplot(eri_pred_df_def, aes(x = elevation, y = cover_focal_sp_unscaled, color = treatment)) +
  geom_point(data = eri_removal, aes(x = elevation, y = cover_focal_sp_percentage, color = treatment), alpha = 0.5) +
  geom_line(size = 1) +
  labs(title = expression(italic(Erigeron~annuus))) +
  facet_wrap(~ year, ncol = 1, scales = "free_y") +
  scale_color_viridis_d() +
  labs(x = "", y = "Cover [%]", color = "Treatment") +
  my_theme +
  scale_y_continuous(breaks = eri_breaks_fun))
                                                          
(sol_plot <- ggplot(sol_pred_df_def, aes(x = elevation, y = cover_focal_sp_unscaled, color = treatment)) +
  geom_point(data = sol_removal, aes(x = elevation, y = cover_focal_sp_percentage, color = treatment), alpha = 0.5) +
  geom_line(size = 1) +
  labs(title = expression(italic(Solidago~canadensis))) +   
  facet_wrap(~ year, ncol = 1) +
  scale_color_viridis_d() +
  labs(x = "Elevation [m]", y = "", color = "Treatment") +
  my_theme +
  scale_y_continuous(breaks = c(0, 17.5, 37.5, 62.5, 87.5)))

(lup_plot <- ggplot(lup_pred_df_def, aes(x = elevation, y = cover_focal_sp_unscaled, color = treatment)) +
  geom_point(data = lup_removal, aes(x = elevation, y = cover_focal_sp_percentage, color = treatment), alpha = 0.5) +
  geom_line(size = 1) +
  labs(title = expression(italic(Lupinus~polyphyllus))) +  
  facet_wrap(~ year, ncol = 1) +
  scale_color_viridis_d() +
  labs(x = "", y = "", color = "Treatment") +
  my_theme +
  scale_y_continuous(breaks = c(0, 17.5, 37.5, 62.5, 87.5)))

# Arrange all plots together
(all_cover_scatterplots <- ggpubr::ggarrange(eri_plot, sol_plot, lup_plot,
                                             ncol = 3, nrow = 1,
                                             common.legend = TRUE, 
                                             legend = "top",
                                             labels = c("a", "b", "c"), 
                                             hjust = -1,
                                             font.label = list(size = 16, color = "black")))

# Export figure
ggsave(filename = "Figures/Fig_3_CoverVsElevation.png", dpi = 700, units = "cm", height = 15, width = 21)
```

# Second version of figure 2 - STILL TO DEBUG

```{r}
# Ensure cover_class exists in all datasets
class_midpoints <- c(0, 0.05, 0.55, 3, 7.5, 17.5, 37.5, 62.5, 87.5)
allowed_mids    <- class_midpoints

# Map % (midpoints) to nearest class index 0-8
to_class <- function(pct) {
  idx <- vapply(pct, function(x) which.min(abs(allowed_mids - x)), integer(1))
  idx - 1L
}

# Add cover_class to each dataset if missing
for (d in c("eri_removal", "sol_removal", "lup_removal")) {
  if (!exists(d)) stop(paste("Dataframe", d, "does not exist yet!"))
  dat <- get(d)
  if (!("cover_focal_sp_percentage" %in% names(dat))) {
    stop(paste("cover_focal_sp_percentage not found in", d))
  }
  dat$cover_class <- to_class(dat$cover_focal_sp_percentage)
  assign(d, dat, envir = .GlobalEnv)
}

# Prediction grids
eri_df <- data.frame(
  elevation = rep(seq(min(eri_removal$elevation), max(eri_removal$elevation), length.out = 100), 2),
  year       = rep(c("2021","2022"), each = 100),
  treatment  = rep(c("control","removal"), each = 1, times = 100)
)
sol_df <- data.frame(
  elevation = rep(seq(min(sol_removal$elevation), max(sol_removal$elevation), length.out = 100), 2),
  year       = rep(c("2021","2022"), each = 100),
  treatment  = rep(c("control","removal"), each = 1, times = 100)
)
lup_df <- data.frame(
  elevation = rep(seq(min(lup_removal$elevation), max(lup_removal$elevation), length.out = 100), 2),
  year       = rep(c("2021","2022"), each = 100),
  treatment  = rep(c("control","removal"), each = 1, times = 100)
)

# Match factor structures to training data before prediction
eri_df$year      <- factor(eri_df$year, levels = levels(eri_removal$year))
eri_df$treatment <- factor(eri_df$treatment, levels = levels(eri_removal$treatment))

sol_df$year      <- factor(sol_df$year, levels = levels(sol_removal$year))
sol_df$treatment <- factor(sol_df$treatment, levels = levels(sol_removal$treatment))

lup_df$year      <- factor(lup_df$year, levels = levels(lup_removal$year))
lup_df$treatment <- factor(lup_df$treatment, levels = levels(lup_removal$treatment))

# Fit GLMMTMB models on the % scale
glmmTMB_formula      <- cover_focal_sp_prop_rescaled ~ year * treatment * elevation
glmmTMB_formula_poly <- cover_focal_sp_prop_rescaled ~ year * treatment * poly(elevation, 2)

eri_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula,      data = eri_removal, family = beta_family())
sol_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula,      data = sol_removal, family = beta_family())
lup_glmmTMB <- glmmTMB::glmmTMB(glmmTMB_formula_poly, data = lup_removal, family = beta_family())

# Predict % from models, then map to class scale for plotting
# Reverse of scales::rescale(to = c(0.001, 0.999))
rescale_back <- function(scaled_vals, orig_min, orig_max, to = c(0.001, 0.999)) {
  (scaled_vals - to[1]) / (to[2] - to[1]) * (orig_max - orig_min) + orig_min
}

eri_min <- min(eri_removal$cover_focal_sp_percentage, na.rm = TRUE)
eri_max <- max(eri_removal$cover_focal_sp_percentage, na.rm = TRUE)
sol_min <- min(sol_removal$cover_focal_sp_percentage, na.rm = TRUE)
sol_max <- max(sol_removal$cover_focal_sp_percentage, na.rm = TRUE)
lup_min <- min(lup_removal$cover_focal_sp_percentage, na.rm = TRUE)
lup_max <- max(lup_removal$cover_focal_sp_percentage, na.rm = TRUE)

# Predicted % (unscaled) -> class index (0-8)
eri_df$pred_pct   <- rescale_back(predict(eri_glmmTMB, newdata = eri_df, type = "response"), eri_min, eri_max)
sol_df$pred_pct   <- rescale_back(predict(sol_glmmTMB, newdata = sol_df, type = "response"), sol_min, sol_max)
lup_df$pred_pct   <- rescale_back(predict(lup_glmmTMB, newdata = lup_df, type = "response"), lup_min, lup_max)

eri_df$pred_class <- to_class(eri_df$pred_pct)
sol_df$pred_class <- to_class(sol_df$pred_pct)
lup_df$pred_class <- to_class(lup_df$pred_pct)

# Factor formatting for observed data
lab_treat <- c(control = "Control", removal = "Removal")
for (d in c("eri_removal","sol_removal","lup_removal")) {
  dat <- get(d)
  dat$treatment <- factor(dat$treatment, levels = c("control","removal"), labels = lab_treat)
  assign(d, dat)
}
eri_df$treatment <- factor(eri_df$treatment, levels = names(lab_treat), labels = lab_treat)
sol_df$treatment <- factor(sol_df$treatment, levels = names(lab_treat), labels = lab_treat)
lup_df$treatment <- factor(lup_df$treatment, levels = names(lab_treat), labels = lab_treat)

# Y-axis: equidistant classes 0-8, labels are % midpoints
y_breaks_classes <- 0:8
y_labels_pct     <- format(class_midpoints, trim = TRUE)

# Plots
(eri_plot <- ggplot(eri_df, aes(x = elevation, y = pred_class, color = treatment)) +
  geom_point(data = eri_removal,
             aes(x = elevation, y = cover_class, color = treatment), alpha = 0.5) +
  geom_line(size = 1) +
  labs(title = expression(italic(Erigeron~annuus))) +
  facet_wrap(~ year, ncol = 1, scales = "free_y") +
  scale_color_viridis_d() +
  labs(x = "", y = "Cover [%]", color = "Treatment") +
  my_theme +
  scale_y_continuous(breaks = y_breaks_classes, labels = y_labels_pct))

(sol_plot <- ggplot(sol_df, aes(x = elevation, y = pred_class, color = treatment)) +
  geom_point(data = sol_removal,
             aes(x = elevation, y = cover_class, color = treatment), alpha = 0.5) +
  geom_line(size = 1) +
  labs(title = expression(italic(Solidago~canadensis))) +
  facet_wrap(~ year, ncol = 1) +
  scale_color_viridis_d() +
  labs(x = "Elevation [m]", y = "", color = "Treatment") +
  my_theme +
  scale_y_continuous(breaks = y_breaks_classes, labels = y_labels_pct))

(lup_plot <- ggplot(lup_df, aes(x = elevation, y = pred_class, color = treatment)) +
  geom_point(data = lup_removal,
             aes(x = elevation, y = cover_class, color = treatment), alpha = 0.5) +
  geom_line(size = 1) +
  labs(title = expression(italic(Lupinus~polyphyllus))) +
  facet_wrap(~ year, ncol = 1) +
  scale_color_viridis_d() +
  labs(x = "", y = "", color = "Treatment") +
  my_theme +
  scale_y_continuous(breaks = y_breaks_classes, labels = y_labels_pct))

# Layout plots together
(all_cover_scatterplots_v2 <- ggpubr::ggarrange(
  eri_plot, sol_plot, lup_plot,
  ncol = 3, nrow = 1, common.legend = TRUE, legend = "top",
  labels = c("a","b","c"), hjust = -1,
  font.label = list(size = 16, color = "black"))
)

# Export
ggsave("Figures/Fig_3_CoverVsElevation_V2.png",
       dpi = 700, units = "cm", height = 15, width = 21)
```

# Calculate mean cover (preparation for Fig. 4)

```{r}
# Calculate mean with tapply & store in nice dataframes
my_rownames <- c("control2021", "control2022", "removal2021", "removal2022")
focal_df <- as.data.frame(sapply(all_species, function(data){tapply(data[, "cover_focal_sp_percentage"], 
                                                             list(data$year, data$treatment), mean, na.rm = T)}),
                          row.names = paste0("focal_sp_", my_rownames))
forbs_df <- as.data.frame(sapply(all_species, function(data){tapply(data[, "forbs_percentage"],
                                                             list(data$year, data$treatment), mean, na.rm = T)}),
                          row.names = paste0("forbs_", my_rownames))
grami_df <- as.data.frame(sapply(all_species, function(data){tapply(data[, "graminoids_percentage"],                                                                          list(data$year, data$treatment), mean, na.rm = T)}),
                          row.names = paste0("graminoids_", my_rownames))
legum_df <- as.data.frame(sapply(all_species, function(data){tapply(data[, "legumes_percentage"], 
                                                             list(data$year, data$treatment), mean, na.rm = T)}),
                          row.names = paste0("legumes_", my_rownames))
bareG_df <- as.data.frame(sapply(all_species, function(data){tapply(data[, "bare_ground_percentage"],
                                                             list(data$year, data$treatment), mean, na.rm = T)}),
                          row.names = paste0("bare_ground_", my_rownames))

# Join into one single dataframe and add relevant columns for plotting
mean_cover_df <- rbind(focal_df, forbs_df, grami_df, legum_df, bareG_df)
mean_cover_df$func_group <- c(rep("focal_sp", 4), rep("forbs", 4), rep("graminoids", 4), rep("legumes", 4), 
                              rep("bare_ground", 4))
mean_cover_df$treatment <- as.factor(rep(c(rep("Control", 2), rep("Removal", 2)), 5))
mean_cover_df$year <- as.factor(rep(c("2021", "2022"), 10))
rm(focal_df, forbs_df, grami_df, legum_df, bareG_df) ; gc()

# Reorder factor level of variable functional group
mean_cover_df <- mean_cover_df %>%
  mutate(func_group = fct_relevel(func_group, "focal_sp", "forbs", "graminoids", "legumes", "bare_ground"))

# Pivot dataframe to get it in long format & subset dfs for single species
mean_cover_df <- mean_cover_df %>% pivot_longer(c(erigeron, solidago, lupinus), values_to = "cover", 
                                                names_to = "species")
eri_mean_cover <- mean_cover_df %>% filter(species == "erigeron")
sol_mean_cover <- mean_cover_df %>% filter(species == "solidago")
lup_mean_cover <- mean_cover_df %>% filter(species == "lupinus")

# Rename factor levels and re-subset sp. specific dataframes
levels(mean_cover_df$func_group) <- c("Focal species", "Forbs", "Graminoids", "Legumes", "Bare ground")
eri_mean_cover <- mean_cover_df %>% filter(species == "erigeron")
sol_mean_cover <- mean_cover_df %>% filter(species == "solidago")
lup_mean_cover <- mean_cover_df %>% filter(species == "lupinus")
```

# Fig. 4: Slopegraphs

```{r}
# Slopegraph function
cover_slopegraph <- function(data, title, ylab, xlab){ 
  
  ggplot(data, aes(x = year, y = cover, color = func_group)) + 
    ggtitle(bquote(italic(.(title)))) +        
    xlab(xlab) + ylab(ylab) +
    geom_line(data = filter(data, data$treatment == "Control"), 
              aes(group = func_group, linetype = treatment), 
              size = 0.7) +
    geom_line(data = filter(data, data$treatment == "Removal"), 
              aes(group = func_group, linetype = treatment), 
              size = 0.7) +
    geom_point(data = filter(data, data$treatment == "Control"), 
               aes(group = func_group, shape = treatment), 
               size = 2) +
    geom_point(data = filter(data, data$treatment == "Removal"), 
               aes(group = func_group, shape = treatment), 
               size = 2) + 
    labs(color = "Functional Group", linetype = "Treatment", shape = "Treatment") +
    my_theme + ggsci::scale_color_startrek()

} 

# Visualize
eri_slope2 <- cover_slopegraph(eri_mean_cover, title = "Erigeron annuus", ylab = "Cover [%]", xlab = "") +
  theme(legend.position = "none") 
sol_slope2 <- cover_slopegraph(sol_mean_cover, title = "Solidago canadensis", ylab = "", xlab = "Year") +
  theme(legend.position = "none") 
lup_slope2 <- cover_slopegraph(lup_mean_cover, title = "Lupinus polyphyllus", ylab = "", xlab = "") +
  labs(color = "Functional group")
(multi_slopegraph <- ggpubr::ggarrange(eri_slope2, sol_slope2, lup_slope2,
                                          ncol=3, nrow=1, common.legend = TRUE, legend="right", 
                                          labels = c("a", "b", "c"), hjust = -1,
                                          font.label = list(size = 16, color = "black")))
# Export in HQ
ggsave(filename = "Figures/Fig_4_multi_funcGroup_slopegraph.png", dpi = 700, units = "cm", height = 12.8, 
       width = 21.5, plot = multi_slopegraph)
```

# Preparative steps for fig.4 with error bars 

```{r}
# --- Tidy the raw data for all species (assumes 'all_species' is a named list: erigeron, solidago, lupinus) ---
make_long <- function(dat, sp_name){
  dat %>%
    transmute(
      species   = sp_name,
      year      = factor(year, levels = c("2021","2022")),
      treatment = factor(treatment, levels = c("control","removal"),
                         labels = c("Control","Removal")),
      `Focal species` = cover_focal_sp_percentage,
      Forbs      = forbs_percentage,
      Graminoids = graminoids_percentage,
      Legumes    = legumes_percentage,
      `Bare ground` = bare_ground_percentage
    ) %>%
    pivot_longer(cols = c(`Focal species`, Forbs, Graminoids, Legumes, `Bare ground`),
                 names_to = "func_group", values_to = "cover")
}

cover_long <- bind_rows(
  make_long(all_species$erigeron, "erigeron"),
  make_long(all_species$solidago, "solidago"),
  make_long(all_species$lupinus,  "lupinus")
)

# Summary stats per panel element
sum_cover <- cover_long %>%
  group_by(species, func_group, year, treatment) %>%
  summarise(
    n    = sum(!is.na(cover)),
    mean = mean(cover, na.rm = TRUE),
    sd   = sd(cover, na.rm = TRUE),
    se   = sd / sqrt(n),
    ci   = 1.96 * se,
    .groups = "drop"
  )

# split by species (to reuse your plotting layout)
eri_sum <- filter(sum_cover, species == "erigeron")
sol_sum <- filter(sum_cover, species == "solidago")
lup_sum <- filter(sum_cover, species == "lupinus")
```

# V2 of Fig. 4 - for supplementary materials

```{r}
# small horizontal dodge
pd <- position_dodge(width = 0.35)

# Define new slopegraph function
cover_slopegraph_ci <- function(data, title, ylab, xlab){
  ggplot(
    data,
    aes(x = year, y = mean, color = func_group,
        group = interaction(func_group, treatment),
        linetype = treatment, shape = treatment)
  ) +
    ggtitle(title) + xlab(xlab) + ylab(ylab) +
    # lines (dodged)
    geom_line(position = pd, linewidth = 0.7) +
    # points (dodged)
    geom_point(position = pd, size = 2) +
    # error bars (95% CI), dodged to match points/lines
    geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci),
                  width = 0.1, position = pd, linewidth = 0.6) +
    labs(color = "Functional Group", linetype = "Treatment", shape = "Treatment") +
    my_theme +
    ggsci::scale_color_startrek()
}

# build panels (italic titles if you like)
eri_slope_ci <- cover_slopegraph_ci(eri_sum, title = expression(italic(Erigeron~annuus)),
                                    ylab = "Cover [%]", xlab = "")
sol_slope_ci <- cover_slopegraph_ci(sol_sum, title = expression(italic(Solidago~canadensis)),
                                    ylab = "", xlab = "Year")
lup_slope_ci <- cover_slopegraph_ci(lup_sum, title = expression(italic(Lupinus~polyphyllus)),
                                    ylab = "", xlab = "")

# Layout plots together
(multi_slopegraph_ci <- ggpubr::ggarrange(
  eri_slope_ci + theme(legend.position = "none"),
  sol_slope_ci + theme(legend.position = "none"),
  lup_slope_ci + labs(color = "Functional Group"),
  ncol = 3, nrow = 1, common.legend = TRUE, legend = "right",
  labels = c("a","b","c"), hjust = -1,
  font.label = list(size = 16, color = "black")))

# Export
ggsave("Figures/Fig_4_multi_funcGroup_slopegraph_V2.png",
       plot = multi_slopegraph_ci, dpi = 700, units = "cm",
       height = 12.8, width = 21.5)
```

# Fig. SX - Visualization of delta cover changes

```{r}
delta_by_plot <- function(df, sp_name){
  # candidate elevation names
  elev_candidates <- c("elevation","elev_m","elevation_raw","elevation_rescaled")
  elev_col <- intersect(elev_candidates, names(df))

  df2 <- df %>%
    dplyr::mutate(year = as.character(year)) %>%
    dplyr::select(
      dplyr::any_of(c("plotID","treatment","year","cover_focal_sp_percentage")),
      tidyselect::all_of(elev_col)              
    )

  # ensure we have elev_m
  if (length(elev_col) == 0) {
    df2$elev_m <- NA_real_
  } else {
    df2 <- dplyr::rename(df2, elev_m = tidyselect::all_of(elev_col[1]))
  }

  df2 %>%
    tidyr::pivot_wider(names_from = year, values_from = cover_focal_sp_percentage) %>%
    dplyr::filter(!is.na(`2021`), !is.na(`2022`)) %>%
    dplyr::transmute(
      species    = sp_name,
      plotID,
      treatment  = factor(treatment, levels = c("control","removal"),
                          labels = c("Control","Removal")),
      elev_m,
      delta      = `2022` - `2021`,
      start_2021 = `2021`
    )
}

# Build Δ table
delta_df <- dplyr::bind_rows(
  delta_by_plot(eri_removal, "Erigeron annuus"),
  delta_by_plot(sol_removal, "Solidago canadensis"),
  delta_by_plot(lup_removal, "Lupinus polyphyllus")
) %>%
  dplyr::mutate(
    species = factor(species,
                     levels = c("Erigeron annuus","Solidago canadensis","Lupinus polyphyllus"))
  )

p_delta <- ggplot(delta_df, aes(x = treatment, y = delta)) +
  # zero line
  geom_hline(yintercept = 0, linewidth = 0.4, linetype = 2, color = "grey40") +

  # violins (soft, no outline)
  geom_violin(aes(fill = treatment),
              width = 0.85, alpha = 0.35, color = NA, trim = TRUE) +

  # jittered points (more horizontal spread to separate them)
  {
    if (color_by_elev) {
      geom_point(aes(color = elev_m),
                 position = position_jitter(width = 0.25, height = 0),
                 alpha = 0.55, size = 2.2, show.legend = TRUE)
    } else {
      geom_point(aes(color = treatment),
                 position = position_jitter(width = 0.25, height = 0),
                 alpha = 0.55, size = 2.2, show.legend = FALSE)
    }
  } +

  # facet by species (keep species names in italics, grey strip)
  facet_wrap(
    ~ species, nrow = 1, scales = "free_y",
    labeller = as_labeller(c(
      "Erigeron annuus"     = expression(italic("Erigeron annuus")),
      "Solidago canadensis" = expression(italic("Solidago canadensis")),
      "Lupinus polyphyllus" = expression(italic("Lupinus polyphyllus"))
    ))
  ) +

  # labels and scales
  scale_x_discrete(NULL) +
  ylab(expression(Delta~"%"~cover~"(2022-2021)")) +
  {
    if (color_by_elev) {
      scale_color_viridis_c(name = "Elevation [m]")
    } else {
      list(
        scale_color_viridis_d(name = "Treatment"),
        scale_fill_viridis_d(guide = "none")
      )
    }
  } +

  # Add panel border
  theme_classic(base_size = 12) +
    theme(axis.line = element_blank(), 
          panel.border = element_rect(color = "black", fill = NA, linewidth = 0.6),
          strip.background = element_rect(fill = "grey85", color = NA),
          strip.text = element_text(face = "italic"),
          legend.position = if (color_by_elev) "right" else "none")

# Save
ggsave("Figures/Fig_Sx_DeltaCover_ViolinJitter.png",
       p_delta, width = 21, height = 8, units = "cm", dpi = 600)
```

Add correlation matrix between variables

```{r}
# Correlation Matrix: Environmental, Anthropogenic, and Survey Data at locations of study sites
# Load required libraries
library(dplyr)
library(terra)
library(corrplot)

# Load rasters once for entire script
# Load raster data from RDS
r_precip <- readRDS("Data/ch_bioclim_chclim25_present_pixel_1981_2010_bio12_25.rds")
r_temp   <- readRDS("Data/ch_bioclim_chclim25_present_pixel_1981_2010_bio1_25.rds")
r_pop    <- readRDS("Data/ch_popdensity_statpop13_pixel_populationdensity.rds")

# Convert to SpatRaster
r_precip <- rast(r_precip)
r_temp   <- rast(r_temp)
r_pop    <- rast(r_pop)

# Prepare base dataset (all sites)
# Site-level summaries (sampling effort, vegetation cover)
site_summary <- removal_data %>%
  group_by(site_name) %>%
  summarise(
    sampling_effort = n(),
    invasive_cover_mean = mean(non_natives_percentage, na.rm = TRUE),
    native_veg_cover_mean = mean(natives_percentage, na.rm = TRUE),
    .groups = "drop"
  )

# Unique site-level spatial data (keep species info for later filtering)
sites_all <- removal_data %>%
  dplyr::select(site_name, species, longitude, latitude, northing, easting, elevation) %>%
  dplyr::distinct(site_name, .keep_all = TRUE)

# Merge site stats
sites_all <- left_join(sites_all, site_summary, by = "site_name")

# Convert to SpatVector
sites_vect_all <- vect(sites_all, geom = c("longitude", "latitude"), crs = "EPSG:4326")

# Extract raster values only once
sites_all$precip      <- terra::extract(r_precip, sites_vect_all)[,2]
sites_all$temp        <- terra::extract(r_temp,   sites_vect_all)[,2]
sites_all$pop_density <- terra::extract(r_pop,    sites_vect_all)[,2]

# Clean memory
rm(r_precip, r_temp, r_pop); gc()

# Loop through species-specific subsets
# Get species list
unique_species <- unique(sites_all$species)

for (sp in unique_species) {

  # Subset by species
  sites <- sites_all %>% filter(species == sp)

  # Prepare correlation dataframe
  cor_data <- sites %>%
    dplyr::select(elevation, precip, temp, pop_density,
                  invasive_cover_mean, native_veg_cover_mean, sampling_effort) %>%
    na.omit()

  # Rename for readability
  colnames(cor_data) <- c("Elevation [m]",
                          "Precipitation",
                          "Temperature",
                          "Pop. Density",
                          "Invasive Cover [%]",
                          "Native Cover [%]",
                          "Sampling Effort")

  # Compute correlation
  cor_mat <- cor(cor_data, method = "pearson")

  # Export species-specific figure
  png(paste0("Figures/Fig_Sx_CorrelationMatrix_", gsub(" ", "_", sp), ".png"),
      width = 12, height = 11, units = "cm", res = 600)
  corrplot(cor_mat,
           method = "color",
           type = "upper",
           addCoef.col = "black",
           tl.col = "black",
           tl.cex = 1.0,
           number.cex = 0.85,
           col = colorRampPalette(c("darkblue", "white", "darkred"))(200),
           diag = FALSE)
  dev.off()
}

# Create full-site (all species) correlation plot
# Final full correlation matrix
cor_data_all <- sites_all %>%
  dplyr::select(elevation, precip, temp, pop_density,
                invasive_cover_mean, native_veg_cover_mean, sampling_effort) %>%
  na.omit()

# Cor matrix
colnames(cor_data_all) <- c("Elevation [m]",
                            "Precipitation",
                            "Temperature",
                            "Pop. Density",
                            "Invasive Cover [%]",
                            "Native Cover [%]",
                            "Sampling Effort")
cor_mat_all <- cor(cor_data_all, method = "pearson")

# Visualize and export
png("Figures/Fig_Sx_CorrelationMatrix_AllSites.png", width = 12, height = 11, units = "cm", res = 600)
corrplot(cor_mat_all,
         method = "color",
         type = "upper",
         addCoef.col = "black",
         tl.col = "black",
         tl.cex = 1.0,
         number.cex = 0.85,
         col = colorRampPalette(c("darkblue", "white", "darkred"))(200),
         diag = FALSE)
dev.off()
```
